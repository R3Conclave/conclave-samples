//package com.r3.conclave.sample.enclave
//
//import com.r3.conclave.common.EnclaveInstanceInfo
//import com.r3.conclave.enclave.Enclave
//import com.r3.conclave.mail.EnclaveMail
//import kotlinx.serialization.ExperimentalSerializationApi
//import kotlinx.serialization.protobuf.ProtoBuf
//import java.security.KeyPair
//import java.security.PublicKey
//
///**
// * TODO
// */
//// TODO no enclave init - JIRA for discussion Shams
//@ExperimentalSerializationApi
//class AzureAppKeyRecoveryEnclave : Enclave() {
//    private val simpleKeyStore = SimpleInMemoryKeyStore()
//
//    // CONSTRAINTS FOR CSS
//    // TODO fill it in with real values, it's placeholder
//    // btw, they don't have a good story for aythentication of CSS within an enclave, maybe hardcoded key, maybe TLS
//    private val azureCloudSealingServiceKey: PublicKey = TODO()
//
//    private val listOfClaims: List<String> = TODO()
//
//    // todo this is probably not needed if we nail the constraints
//    // todo think of the overwriting the key and data migration
//    private val keyRequested: Boolean = false
//
//    // In Azure case we can't reuse mail protocol communication
//    // Moreover we don't have TLS inside enclaves
//    // For now this protocol will be authenticated by hardcoded public key
//    // TODO there is no protection against replay attacks :/
//    override fun receiveFromUntrustedHost(bytes: ByteArray): ByteArray? {
//        val result = ByteArray(bytes.size)
//        for (i in bytes.indices) result[i] = bytes[bytes.size - 1 - i]
//        return result
//    }
//
//    // TODO SIDE CHANNELS, think how we could obfuscate the fact that we are handling key request/response
//    //  should we have special messages and reserved topic? we need routing coordination from a host perspective anyway...
//    override fun receiveMail(id: Long, mail: EnclaveMail, routingHint: String?) {
//        routingHint!!  // Ensure that the routingHint isn't null
//        // TODO REFACTOR don't pass it as routing hint/reuse header/body
//        if (routingHint == SHARED_KEY_HINT) {
//            loadSharedKey(mail)
//        } else if (routingHint == SELF_HINT) {
//            handleMailToSelf(mail)
//        } else {
//            // TODO handle this case, for demo we will add sealing
//            throw IllegalArgumentException("This enclave only does key loading and sharing")
//        }
//    }
//
//    private fun handleAzureResponse() {
//        TODO()
//    }
//
//    private fun azureAttestation() {
//        TODO()
//    }
//
//    private fun saveAzureKey() {
//        TODO()
//    }
//
//    private fun loadAzureKey() {
//        TODO()
//    }
//
//
//    ///////////////////////////////////////////// FILE STUFF, MOVE IT TO INTERFACE FOR BOTH DEMOS
//    // Possible scenarios on key loading from mail to self:
//    // 1. header constraints don't match
//    //  - means we got key that either is generated by an outdated enclave and we need to perform data migration/request a new key
//    //  - means that host fed us old message (replay) - request a new key too
//    //  - message is malformed, ie EnclaveInstanceInfo deserialization fails
//    // 2. sender doesn't match
//    //  - TODO check with Shams, it should probably throw immediately?
//    // 3. We cannot decrypt the body - this will throw before the receive TODO check it
//    //  - scenario handled by host
//
//    // If this one is called, then it means mail was successfully decrypted, so we need to check constraints
//    // and load key
//    private fun loadSharedKey(mail: EnclaveMail) {
//        // First check the enclave instance info that we received in the header against the hardcoded constraints
////        val instanceInfo = checkHeaderConstraints(mail) // throws - THIS SHOULD cause key recovery too
//        // Verify that sender is us/ TODO think about it
////        checkSender(mail)
//        val mailBody = mail.bodyAsBytes
//        val keyResponse: KeyResponse = ProtoBuf.decodeFromByteArray(KeyResponse.serializer(), mail.bodyAsBytes)
//        // this happens after the mail got decrypted
//
//        // decrypt the mail body
//        // if succesful
//        //      extract private key from the body and save it as a cluster key
//        //      switch the public key to be a new public key of an enclave
//        //      generate new Remote attestation TODO CLUSTER RA
//        //      TODO coordinate with the host
//        // TODO acknowledge
//
//
//        /////////////////////////////////////
//        TODO()
//        // TODO implement scenario for key fallback
//        // extract remote attestation from the header
//        // verify the remote attestation with the constraint TODO
//        // decrypt the mail body
//        // if succesful
//        //      extract private key from the body and save it as a cluster key
//        //      switch the public key to be a new public key of an enclave
//        //      generate new Remote attestation TODO CLUSTER RA
//        //      TODO coordinate with the host
//        // else if not successful
//        //      here we have a case we moved machines,
//        //      we need to start recovery process using another enclave/cluster/key-vault enclave
//        //      exception - host catches
////        val sharedKey: KeyPair = TODO()
////        loadSharedKey(sharedKey)
//        // TODO call internal function to load shared key in conclave mail
//        // TODO now... attestation ;)
//    }
//
//    private fun handleMailToSelf(mail: EnclaveMail) {
//        mail.envelope
//        val mailBody = mail.bodyAsBytes
//        // store secret data for key derivation
//        TODO()
//    }
//
//    private fun saveSharedKey(sharedKey: KeyPair, keyDerivationRA: EnclaveInstanceInfo) {
//        // Get shared key - that would be call on Enclave.sharedKey, for now I just have mock key service here
//        val sharedKey = simpleKeyStore.retrieveKey(1) ?: throw IllegalArgumentException("TODO")
//        val postOffice = this.enclaveInstanceInfo.createPostOffice()
//        val body = sharedKey.serialiseWith(KeyPairSerializer)
//        val header = keyDerivationRA.serialize() // header - EnclaveInstanceInfo of the KDE (any)
//        val mail = postOffice.encryptMail(body, header)
//        postMail(mail, SHARED_KEY_HINT)
//    }
//
//
//    ///////////////////////////////////////////// SEALING DEMO
//    private fun generateAndSealData() {
//        // generate random number
//        // send it as mail to self
//    }
//
//    private fun readSealedData() {
//        // sent as mail to self, read it and print out
//
//    }
//    ///////////////////////////////////////////// END SEALING DEMO
//}
//
//
//// This is used when the host delivers a message from the client.
//// First, decode mail body as a String.
////        val stringToReverse = String(mail.bodyAsBytes)
////        // Reverse it and re-encode to UTF-8 to send back.
////        val reversedEncodedString: ByteArray = reverse(stringToReverse).toByteArray()
////        // Get the post office object for responding back to this mail and use it to encrypt our response.
////        val responseBytes = postOffice(mail).encryptMail(reversedEncodedString)
////        postMail(responseBytes, routingHint)
